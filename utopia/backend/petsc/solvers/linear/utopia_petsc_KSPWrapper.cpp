#include "utopia_petsc_KSPWrapper.hpp"
#include "utopia_petsc_Types.hpp"

namespace utopia {
	//TODO check what solvers are available in petsc based on the compilation and version

	KSPTypes::KSPTypes():
	ksp_({
		KSPRICHARDSON,
		KSPCHEBYSHEV,
		KSPCG,
		KSPGROPPCG,
		KSPPIPECG,
		KSPPIPECGRR,
//Not reallu there in 3.9.0
// #if UTOPIA_PETSC_VERSION_GREATER_EQUAL_THAN(3,9,0)
// 		KSPPIPELCG,
// #endif
		KSPCGNE,
#if UTOPIA_PETSC_VERSION_GREATER_EQUAL_THAN(3,8,0)
		KSPCGNASH,
		KSPCGSTCG,
		KSPCGGLTR,
		KSPFETIDP,
		KSPPIPEBCGS,
#else
		KSPSTCG,
		KSPGLTR,
		KSPNASH,
#endif
		KSPFCG,
		KSPPIPEFCG,
		KSPGMRES,
		KSPPIPEFGMRES,
		KSPFGMRES,
		KSPLGMRES,
		KSPDGMRES,
		KSPPGMRES,
		KSPTCQMR,
		KSPBCGS,
		KSPIBCGS,
		KSPFBCGS,
		KSPFBCGSR,
		KSPBCGSL,
		KSPCGS,
		KSPTFQMR,
		KSPCR,
		KSPPIPECR,
		KSPLSQR,
		KSPPREONLY,
		KSPQCG,
		KSPBICG,
		KSPMINRES,
		KSPSYMMLQ,
		KSPLCD,
		KSPPYTHON,
		KSPGCR,
		KSPPIPEGCR,
		KSPTSIRM,
		KSPCGLS
	}),
	pc_({
		PCJACOBI,
		PCSOR,
		PCLU,
		PCSHELL,
		PCBJACOBI,
		PCMG,
		PCEISENSTAT,
		PCILU,
		PCICC,
		PCASM,
		PCGASM,
		PCKSP,
		PCCOMPOSITE,
		PCREDUNDANT,
		PCSPAI,
		PCNN,
		PCCHOLESKY,
		PCPBJACOBI,
		PCMAT,
		PCHYPRE,
		PCPARMS,
		PCFIELDSPLIT,
		PCTFS,
		PCML,
		PCGALERKIN,
		PCEXOTIC,
		PCCP,
		PCBFBT,
		PCLSC,
		PCPYTHON,
		PCPFMG,
		PCSYSPFMG,
		PCREDISTRIBUTE,
		PCSVD,
		PCGAMG,
#if UTOPIA_PETSC_VERSION_GREATER_EQUAL_THAN(3,8,0)
		PCCHOWILUVIENNACL,
		PCROWSCALINGVIENNACL,
		PCSAVIENNACL,
#endif
		PCBDDC,
		PCKACZMARZ,
		PCTELESCOPE,
		PCNONE
	}),
	package_({" ", "petsc", "mumps", "superlu", "superlu_dist" })
	{}


	std::string converged_str(KSPConvergedReason reason)
	{
		switch(reason) {
			/* converged */
			case KSP_CONVERGED_RTOL_NORMAL: { return "KSP_CONVERGED_RTOL_NORMAL"; }
			case KSP_CONVERGED_ATOL_NORMAL: { return "KSP_CONVERGED_ATOL_NORMAL"; }
			case KSP_CONVERGED_RTOL: { return "KSP_CONVERGED_RTOL"; }
			case KSP_CONVERGED_ATOL: { return "KSP_CONVERGED_ATOL"; }
			case KSP_CONVERGED_ITS: { return "KSP_CONVERGED_ITS"; }
			case KSP_CONVERGED_CG_NEG_CURVE: { return "KSP_CONVERGED_CG_NEG_CURVE"; }
			case KSP_CONVERGED_CG_CONSTRAINED: { return "KSP_CONVERGED_CG_CONSTRAINED"; }
			case KSP_CONVERGED_STEP_LENGTH: { return "KSP_CONVERGED_STEP_LENGTH"; }
			case KSP_CONVERGED_HAPPY_BREAKDOWN: { return "KSP_CONVERGED_HAPPY_BREAKDOWN"; }
         	/* diverged */
			case KSP_DIVERGED_NULL: { return "KSP_DIVERGED_NULL"; }
			case KSP_DIVERGED_ITS: { return "KSP_DIVERGED_ITS"; }
			case KSP_DIVERGED_DTOL: { return "KSP_DIVERGED_DTOL"; }
			case KSP_DIVERGED_BREAKDOWN: { return "KSP_DIVERGED_BREAKDOWN"; }
			case KSP_DIVERGED_BREAKDOWN_BICG: { return "KSP_DIVERGED_BREAKDOWN_BICG"; }
			case KSP_DIVERGED_NONSYMMETRIC: { return "KSP_DIVERGED_NONSYMMETRIC"; }
			case KSP_DIVERGED_INDEFINITE_PC: { return "KSP_DIVERGED_INDEFINITE_PC"; }
			case KSP_DIVERGED_NANORINF: { return "KSP_DIVERGED_NANORINF"; }
			case KSP_DIVERGED_INDEFINITE_MAT: { return "KSP_DIVERGED_INDEFINITE_MAT"; }
			case KSP_DIVERGED_PCSETUP_FAILED: { return "KSP_DIVERGED_PCSETUP_FAILED"; }
			case KSP_CONVERGED_ITERATING: { return "KSP_CONVERGED_ITERATING"; }

			default: {
				return "unknown code";
			}
		}	
	}

	template class KSPWrapper<DSMatrixd, DVectord>;
}
